$date
	Mon Dec  2 12:07:32 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module selevytest $end
$var reg 1 ! CLK $end
$var reg 1 " reset $end
$var integer 32 # i [31:0] $end
$scope module s $end
$var wire 1 ! CLK $end
$var wire 1 " reset $end
$var wire 32 $ signextnr_out [31:0] $end
$var wire 32 % rom_out [31:0] $end
$var wire 32 & rf_write_data [31:0] $end
$var wire 1 ' rf_regwrite $end
$var wire 32 ( rf_out2 [31:0] $end
$var wire 32 ) rf_out1 [31:0] $end
$var wire 32 * ram_read_data [31:0] $end
$var wire 32 + pc_out [31:0] $end
$var wire 32 , pc_addr [31:0] $end
$var wire 32 - incpc_out [31:0] $end
$var wire 1 . ctrl_memwrite $end
$var wire 1 / ctrl_memread $end
$var wire 1 0 ctrl_load $end
$var wire 2 1 ctrl_extnrops [1:0] $end
$var wire 1 2 ctrl_branch $end
$var wire 1 3 ctrl_alusrc $end
$var wire 2 4 ctrl_aluops [1:0] $end
$var wire 32 5 br_tgt_target [31:0] $end
$var wire 2 6 aluctrl_out [1:0] $end
$var wire 1 7 alu_zero $end
$var wire 32 8 alu_read2 [31:0] $end
$var wire 32 9 alu_out [31:0] $end
$scope module alu $end
$var wire 32 : read2 [31:0] $end
$var wire 1 7 zero $end
$var wire 32 ; read1 [31:0] $end
$var wire 2 < ops [1:0] $end
$var reg 32 = out [31:0] $end
$upscope $end
$scope module aluctrl $end
$var wire 3 > funct [2:0] $end
$var wire 1 ? thirty $end
$var wire 2 @ ops [1:0] $end
$var reg 2 A out [1:0] $end
$upscope $end
$scope module br_tgt $end
$var wire 32 B target [31:0] $end
$var wire 32 C addr2 [31:0] $end
$var wire 32 D addr1 [31:0] $end
$upscope $end
$scope module ctrl $end
$var wire 7 E read [6:0] $end
$var reg 2 F aluops [1:0] $end
$var reg 1 3 alusrc $end
$var reg 1 2 branch $end
$var reg 2 G extnrops [1:0] $end
$var reg 1 0 load $end
$var reg 1 / memread $end
$var reg 1 . memwrite $end
$var reg 1 ' regwrite $end
$upscope $end
$scope module incpc $end
$var wire 32 H out [31:0] $end
$var wire 32 I addr [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 ! CLK $end
$var wire 32 J addr [31:0] $end
$var wire 1 " reset $end
$var reg 32 K out [31:0] $end
$upscope $end
$scope module ram $end
$var wire 1 ! CLK $end
$var wire 32 L addr [31:0] $end
$var wire 1 / memread $end
$var wire 1 . memwrite $end
$var wire 1 " reset $end
$var wire 32 M write_data [31:0] $end
$var reg 32 N read_data [31:0] $end
$scope begin rst $end
$var integer 32 O i [31:0] $end
$upscope $end
$upscope $end
$scope module regfile $end
$var wire 1 ! CLK $end
$var wire 32 P out1 [31:0] $end
$var wire 32 Q out2 [31:0] $end
$var wire 5 R read1 [4:0] $end
$var wire 5 S read2 [4:0] $end
$var wire 1 ' regwrite $end
$var wire 1 " reset $end
$var wire 5 T write1 [4:0] $end
$var wire 32 U write_data [31:0] $end
$scope begin rst $end
$var integer 32 V i [31:0] $end
$upscope $end
$upscope $end
$scope module rom $end
$var wire 32 W out [31:0] $end
$var wire 32 X read_addr [31:0] $end
$var wire 1 " reset $end
$scope begin rst $end
$var integer 32 Y i [31:0] $end
$scope begin zero $end
$upscope $end
$upscope $end
$upscope $end
$scope module signextnr $end
$var wire 2 Z ops [1:0] $end
$var wire 32 [ read [31:0] $end
$var wire 32 \ out [31:0] $end
$scope function signextend $end
$var reg 32 ] in [31:0] $end
$var reg 32 ^ signextend [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
x?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
x7
bx 6
bx 5
bx 4
x3
x2
bx 1
x0
x/
x.
bx -
bx ,
bx +
bx *
bx )
bx (
x'
bx &
bx %
bx $
bx #
0"
0!
$end
#1000
b11 &
b11 U
07
b11 9
b11 =
b11 L
b10 6
b10 <
b10 A
b1 ,
b1 J
1'
0.
0/
b11 1
b11 G
b11 Z
b10 4
b10 @
b10 F
00
03
02
b10 8
b10 :
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx $
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx C
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ^
b1000001000000010110011 ]
0?
b0 >
b110011 E
b1 T
b10 (
b10 M
b10 Q
b10 S
b1 )
b1 ;
b1 P
b1 R
b1000001000000010110011 %
b1000001000000010110011 W
b1000001000000010110011 [
b1 -
b1 H
b0 +
b0 D
b0 I
b0 K
b0 X
b1000000 O
b100000 V
b1000000 Y
1"
#2000
b10 #
0"
#3000
b1 &
b1 U
b11 6
b11 <
b11 A
b1 9
b1 =
b1 L
b1 5
b1 B
b0 $
b0 C
b0 \
b0 ^
b1000000001000001000000010110011 ]
1?
b10 ,
b10 J
b1000000001000001000000010110011 %
b1000000001000001000000010110011 W
b1000000001000001000000010110011 [
b10 -
b10 H
b1 +
b1 D
b1 I
b1 K
b1 X
b11 )
b11 ;
b11 P
1!
#4000
0!
#5000
b0 &
b0 U
17
b11 6
b11 <
b11 A
0'
b0 1
b0 G
b0 Z
b0 4
b0 @
b0 F
b0 9
b0 =
b0 L
b0 8
b0 :
b0 ]
0?
b0 E
b0 T
b0 (
b0 M
b0 Q
b0 S
b0 R
b11 ,
b11 J
b0 )
b0 ;
b0 P
b0 %
b0 W
b0 [
b11 -
b11 H
b10 5
b10 B
b10 +
b10 D
b10 I
b10 K
b10 X
1!
#6000
0!
#7000
